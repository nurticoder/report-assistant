/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/zip-stream";
exports.ids = ["vendor-chunks/zip-stream"];
exports.modules = {

/***/ "(rsc)/./node_modules/zip-stream/index.js":
/*!******************************************!*\
  !*** ./node_modules/zip-stream/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * ZipStream\n *\n * @ignore\n * @license [MIT]{@link https://github.com/archiverjs/node-zip-stream/blob/master/LICENSE}\n * @copyright (c) 2014 Chris Talkington, contributors.\n */\nvar inherits = (__webpack_require__(/*! util */ \"util\").inherits);\n\nvar ZipArchiveOutputStream = (__webpack_require__(/*! compress-commons */ \"(rsc)/./node_modules/compress-commons/lib/compress-commons.js\").ZipArchiveOutputStream);\nvar ZipArchiveEntry = (__webpack_require__(/*! compress-commons */ \"(rsc)/./node_modules/compress-commons/lib/compress-commons.js\").ZipArchiveEntry);\n\nvar util = __webpack_require__(/*! archiver-utils */ \"(rsc)/./node_modules/zip-stream/node_modules/archiver-utils/index.js\");\n\n/**\n * @constructor\n * @extends external:ZipArchiveOutputStream\n * @param {Object} [options]\n * @param {String} [options.comment] Sets the zip archive comment.\n * @param {Boolean} [options.forceLocalTime=false] Forces the archive to contain local file times instead of UTC.\n * @param {Boolean} [options.forceZip64=false] Forces the archive to contain ZIP64 headers.\n * @param {Boolean} [options.store=false] Sets the compression method to STORE.\n * @param {Object} [options.zlib] Passed to [zlib]{@link https://nodejs.org/api/zlib.html#zlib_class_options}\n * to control compression.\n */\nvar ZipStream = module.exports = function(options) {\n  if (!(this instanceof ZipStream)) {\n    return new ZipStream(options);\n  }\n\n  options = this.options = options || {};\n  options.zlib = options.zlib || {};\n\n  ZipArchiveOutputStream.call(this, options);\n\n  if (typeof options.level === 'number' && options.level >= 0) {\n    options.zlib.level = options.level;\n    delete options.level;\n  }\n\n  if (!options.forceZip64 && typeof options.zlib.level === 'number' && options.zlib.level === 0) {\n    options.store = true;\n  }\n\n  options.namePrependSlash = options.namePrependSlash || false;\n\n  if (options.comment && options.comment.length > 0) {\n    this.setComment(options.comment);\n  }\n};\n\ninherits(ZipStream, ZipArchiveOutputStream);\n\n/**\n * Normalizes entry data with fallbacks for key properties.\n *\n * @private\n * @param  {Object} data\n * @return {Object}\n */\nZipStream.prototype._normalizeFileData = function(data) {\n  data = util.defaults(data, {\n    type: 'file',\n    name: null,\n    namePrependSlash: this.options.namePrependSlash,\n    linkname: null,\n    date: null,\n    mode: null,\n    store: this.options.store,\n    comment: ''\n  });\n\n  var isDir = data.type === 'directory';\n  var isSymlink = data.type === 'symlink';\n\n  if (data.name) {\n    data.name = util.sanitizePath(data.name);\n\n    if (!isSymlink && data.name.slice(-1) === '/') {\n      isDir = true;\n      data.type = 'directory';\n    } else if (isDir) {\n      data.name += '/';\n    }\n  }\n\n  if (isDir || isSymlink) {\n    data.store = true;\n  }\n\n  data.date = util.dateify(data.date);\n\n  return data;\n};\n\n/**\n * Appends an entry given an input source (text string, buffer, or stream).\n *\n * @param  {(Buffer|Stream|String)} source The input source.\n * @param  {Object} data\n * @param  {String} data.name Sets the entry name including internal path.\n * @param  {String} [data.comment] Sets the entry comment.\n * @param  {(String|Date)} [data.date=NOW()] Sets the entry date.\n * @param  {Number} [data.mode=D:0755/F:0644] Sets the entry permissions.\n * @param  {Boolean} [data.store=options.store] Sets the compression method to STORE.\n * @param  {String} [data.type=file] Sets the entry type. Defaults to `directory`\n * if name ends with trailing slash.\n * @param  {Function} callback\n * @return this\n */\nZipStream.prototype.entry = function(source, data, callback) {\n  if (typeof callback !== 'function') {\n    callback = this._emitErrorCallback.bind(this);\n  }\n\n  data = this._normalizeFileData(data);\n\n  if (data.type !== 'file' && data.type !== 'directory' && data.type !== 'symlink') {\n    callback(new Error(data.type + ' entries not currently supported'));\n    return;\n  }\n\n  if (typeof data.name !== 'string' || data.name.length === 0) {\n    callback(new Error('entry name must be a non-empty string value'));\n    return;\n  }\n\n  if (data.type === 'symlink' && typeof data.linkname !== 'string') {\n    callback(new Error('entry linkname must be a non-empty string value when type equals symlink'));\n    return;\n  }\n\n  var entry = new ZipArchiveEntry(data.name);\n  entry.setTime(data.date, this.options.forceLocalTime);\n\n  if (data.namePrependSlash) {\n    entry.setName(data.name, true);\n  }\n\n  if (data.store) {\n    entry.setMethod(0);\n  }\n\n  if (data.comment.length > 0) {\n    entry.setComment(data.comment);\n  }\n\n  if (data.type === 'symlink' && typeof data.mode !== 'number') {\n    data.mode = 40960; // 0120000\n  }\n\n  if (typeof data.mode === 'number') {\n    if (data.type === 'symlink') {\n      data.mode |= 40960;\n    }\n\n    entry.setUnixMode(data.mode);\n  }\n\n  if (data.type === 'symlink' && typeof data.linkname === 'string') {\n    source = Buffer.from(data.linkname);\n  }\n\n  return ZipArchiveOutputStream.prototype.entry.call(this, entry, source, callback);\n};\n\n/**\n * Finalizes the instance and prevents further appending to the archive\n * structure (queue will continue til drained).\n *\n * @return void\n */\nZipStream.prototype.finalize = function() {\n  this.finish();\n};\n\n/**\n * Returns the current number of bytes written to this stream.\n * @function ZipStream#getBytesWritten\n * @returns {Number}\n */\n\n/**\n * Compress Commons ZipArchiveOutputStream\n * @external ZipArchiveOutputStream\n * @see {@link https://github.com/archiverjs/node-compress-commons}\n */\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvemlwLXN0cmVhbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsZUFBZSxrREFBd0I7O0FBRXZDLDZCQUE2QixxSUFBa0Q7QUFDL0Usc0JBQXNCLDhIQUEyQzs7QUFFakUsV0FBVyxtQkFBTyxDQUFDLDRGQUFnQjs7QUFFbkM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVEsZ0NBQWdDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSx3QkFBd0I7QUFDcEMsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxlQUFlO0FBQzNCLFlBQVksUUFBUTtBQUNwQixZQUFZLFNBQVM7QUFDckIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZXBvcnQtYXNzaXN0YW50Ly4vbm9kZV9tb2R1bGVzL3ppcC1zdHJlYW0vaW5kZXguanM/NTY5YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFppcFN0cmVhbVxuICpcbiAqIEBpZ25vcmVcbiAqIEBsaWNlbnNlIFtNSVRde0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9hcmNoaXZlcmpzL25vZGUtemlwLXN0cmVhbS9ibG9iL21hc3Rlci9MSUNFTlNFfVxuICogQGNvcHlyaWdodCAoYykgMjAxNCBDaHJpcyBUYWxraW5ndG9uLCBjb250cmlidXRvcnMuXG4gKi9cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ3V0aWwnKS5pbmhlcml0cztcblxudmFyIFppcEFyY2hpdmVPdXRwdXRTdHJlYW0gPSByZXF1aXJlKCdjb21wcmVzcy1jb21tb25zJykuWmlwQXJjaGl2ZU91dHB1dFN0cmVhbTtcbnZhciBaaXBBcmNoaXZlRW50cnkgPSByZXF1aXJlKCdjb21wcmVzcy1jb21tb25zJykuWmlwQXJjaGl2ZUVudHJ5O1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2FyY2hpdmVyLXV0aWxzJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBleHRlcm5hbDpaaXBBcmNoaXZlT3V0cHV0U3RyZWFtXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuY29tbWVudF0gU2V0cyB0aGUgemlwIGFyY2hpdmUgY29tbWVudC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZm9yY2VMb2NhbFRpbWU9ZmFsc2VdIEZvcmNlcyB0aGUgYXJjaGl2ZSB0byBjb250YWluIGxvY2FsIGZpbGUgdGltZXMgaW5zdGVhZCBvZiBVVEMuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZvcmNlWmlwNjQ9ZmFsc2VdIEZvcmNlcyB0aGUgYXJjaGl2ZSB0byBjb250YWluIFpJUDY0IGhlYWRlcnMuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnN0b3JlPWZhbHNlXSBTZXRzIHRoZSBjb21wcmVzc2lvbiBtZXRob2QgdG8gU1RPUkUuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuemxpYl0gUGFzc2VkIHRvIFt6bGliXXtAbGluayBodHRwczovL25vZGVqcy5vcmcvYXBpL3psaWIuaHRtbCN6bGliX2NsYXNzX29wdGlvbnN9XG4gKiB0byBjb250cm9sIGNvbXByZXNzaW9uLlxuICovXG52YXIgWmlwU3RyZWFtID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBaaXBTdHJlYW0pKSB7XG4gICAgcmV0dXJuIG5ldyBaaXBTdHJlYW0ob3B0aW9ucyk7XG4gIH1cblxuICBvcHRpb25zID0gdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy56bGliID0gb3B0aW9ucy56bGliIHx8IHt9O1xuXG4gIFppcEFyY2hpdmVPdXRwdXRTdHJlYW0uY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICBpZiAodHlwZW9mIG9wdGlvbnMubGV2ZWwgPT09ICdudW1iZXInICYmIG9wdGlvbnMubGV2ZWwgPj0gMCkge1xuICAgIG9wdGlvbnMuemxpYi5sZXZlbCA9IG9wdGlvbnMubGV2ZWw7XG4gICAgZGVsZXRlIG9wdGlvbnMubGV2ZWw7XG4gIH1cblxuICBpZiAoIW9wdGlvbnMuZm9yY2VaaXA2NCAmJiB0eXBlb2Ygb3B0aW9ucy56bGliLmxldmVsID09PSAnbnVtYmVyJyAmJiBvcHRpb25zLnpsaWIubGV2ZWwgPT09IDApIHtcbiAgICBvcHRpb25zLnN0b3JlID0gdHJ1ZTtcbiAgfVxuXG4gIG9wdGlvbnMubmFtZVByZXBlbmRTbGFzaCA9IG9wdGlvbnMubmFtZVByZXBlbmRTbGFzaCB8fCBmYWxzZTtcblxuICBpZiAob3B0aW9ucy5jb21tZW50ICYmIG9wdGlvbnMuY29tbWVudC5sZW5ndGggPiAwKSB7XG4gICAgdGhpcy5zZXRDb21tZW50KG9wdGlvbnMuY29tbWVudCk7XG4gIH1cbn07XG5cbmluaGVyaXRzKFppcFN0cmVhbSwgWmlwQXJjaGl2ZU91dHB1dFN0cmVhbSk7XG5cbi8qKlxuICogTm9ybWFsaXplcyBlbnRyeSBkYXRhIHdpdGggZmFsbGJhY2tzIGZvciBrZXkgcHJvcGVydGllcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICB7T2JqZWN0fSBkYXRhXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblppcFN0cmVhbS5wcm90b3R5cGUuX25vcm1hbGl6ZUZpbGVEYXRhID0gZnVuY3Rpb24oZGF0YSkge1xuICBkYXRhID0gdXRpbC5kZWZhdWx0cyhkYXRhLCB7XG4gICAgdHlwZTogJ2ZpbGUnLFxuICAgIG5hbWU6IG51bGwsXG4gICAgbmFtZVByZXBlbmRTbGFzaDogdGhpcy5vcHRpb25zLm5hbWVQcmVwZW5kU2xhc2gsXG4gICAgbGlua25hbWU6IG51bGwsXG4gICAgZGF0ZTogbnVsbCxcbiAgICBtb2RlOiBudWxsLFxuICAgIHN0b3JlOiB0aGlzLm9wdGlvbnMuc3RvcmUsXG4gICAgY29tbWVudDogJydcbiAgfSk7XG5cbiAgdmFyIGlzRGlyID0gZGF0YS50eXBlID09PSAnZGlyZWN0b3J5JztcbiAgdmFyIGlzU3ltbGluayA9IGRhdGEudHlwZSA9PT0gJ3N5bWxpbmsnO1xuXG4gIGlmIChkYXRhLm5hbWUpIHtcbiAgICBkYXRhLm5hbWUgPSB1dGlsLnNhbml0aXplUGF0aChkYXRhLm5hbWUpO1xuXG4gICAgaWYgKCFpc1N5bWxpbmsgJiYgZGF0YS5uYW1lLnNsaWNlKC0xKSA9PT0gJy8nKSB7XG4gICAgICBpc0RpciA9IHRydWU7XG4gICAgICBkYXRhLnR5cGUgPSAnZGlyZWN0b3J5JztcbiAgICB9IGVsc2UgaWYgKGlzRGlyKSB7XG4gICAgICBkYXRhLm5hbWUgKz0gJy8nO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc0RpciB8fCBpc1N5bWxpbmspIHtcbiAgICBkYXRhLnN0b3JlID0gdHJ1ZTtcbiAgfVxuXG4gIGRhdGEuZGF0ZSA9IHV0aWwuZGF0ZWlmeShkYXRhLmRhdGUpO1xuXG4gIHJldHVybiBkYXRhO1xufTtcblxuLyoqXG4gKiBBcHBlbmRzIGFuIGVudHJ5IGdpdmVuIGFuIGlucHV0IHNvdXJjZSAodGV4dCBzdHJpbmcsIGJ1ZmZlciwgb3Igc3RyZWFtKS5cbiAqXG4gKiBAcGFyYW0gIHsoQnVmZmVyfFN0cmVhbXxTdHJpbmcpfSBzb3VyY2UgVGhlIGlucHV0IHNvdXJjZS5cbiAqIEBwYXJhbSAge09iamVjdH0gZGF0YVxuICogQHBhcmFtICB7U3RyaW5nfSBkYXRhLm5hbWUgU2V0cyB0aGUgZW50cnkgbmFtZSBpbmNsdWRpbmcgaW50ZXJuYWwgcGF0aC5cbiAqIEBwYXJhbSAge1N0cmluZ30gW2RhdGEuY29tbWVudF0gU2V0cyB0aGUgZW50cnkgY29tbWVudC5cbiAqIEBwYXJhbSAgeyhTdHJpbmd8RGF0ZSl9IFtkYXRhLmRhdGU9Tk9XKCldIFNldHMgdGhlIGVudHJ5IGRhdGUuXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IFtkYXRhLm1vZGU9RDowNzU1L0Y6MDY0NF0gU2V0cyB0aGUgZW50cnkgcGVybWlzc2lvbnMuXG4gKiBAcGFyYW0gIHtCb29sZWFufSBbZGF0YS5zdG9yZT1vcHRpb25zLnN0b3JlXSBTZXRzIHRoZSBjb21wcmVzc2lvbiBtZXRob2QgdG8gU1RPUkUuXG4gKiBAcGFyYW0gIHtTdHJpbmd9IFtkYXRhLnR5cGU9ZmlsZV0gU2V0cyB0aGUgZW50cnkgdHlwZS4gRGVmYXVsdHMgdG8gYGRpcmVjdG9yeWBcbiAqIGlmIG5hbWUgZW5kcyB3aXRoIHRyYWlsaW5nIHNsYXNoLlxuICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJuIHRoaXNcbiAqL1xuWmlwU3RyZWFtLnByb3RvdHlwZS5lbnRyeSA9IGZ1bmN0aW9uKHNvdXJjZSwgZGF0YSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gdGhpcy5fZW1pdEVycm9yQ2FsbGJhY2suYmluZCh0aGlzKTtcbiAgfVxuXG4gIGRhdGEgPSB0aGlzLl9ub3JtYWxpemVGaWxlRGF0YShkYXRhKTtcblxuICBpZiAoZGF0YS50eXBlICE9PSAnZmlsZScgJiYgZGF0YS50eXBlICE9PSAnZGlyZWN0b3J5JyAmJiBkYXRhLnR5cGUgIT09ICdzeW1saW5rJykge1xuICAgIGNhbGxiYWNrKG5ldyBFcnJvcihkYXRhLnR5cGUgKyAnIGVudHJpZXMgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQnKSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBkYXRhLm5hbWUgIT09ICdzdHJpbmcnIHx8IGRhdGEubmFtZS5sZW5ndGggPT09IDApIHtcbiAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ2VudHJ5IG5hbWUgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcgdmFsdWUnKSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGRhdGEudHlwZSA9PT0gJ3N5bWxpbmsnICYmIHR5cGVvZiBkYXRhLmxpbmtuYW1lICE9PSAnc3RyaW5nJykge1xuICAgIGNhbGxiYWNrKG5ldyBFcnJvcignZW50cnkgbGlua25hbWUgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcgdmFsdWUgd2hlbiB0eXBlIGVxdWFscyBzeW1saW5rJykpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBlbnRyeSA9IG5ldyBaaXBBcmNoaXZlRW50cnkoZGF0YS5uYW1lKTtcbiAgZW50cnkuc2V0VGltZShkYXRhLmRhdGUsIHRoaXMub3B0aW9ucy5mb3JjZUxvY2FsVGltZSk7XG5cbiAgaWYgKGRhdGEubmFtZVByZXBlbmRTbGFzaCkge1xuICAgIGVudHJ5LnNldE5hbWUoZGF0YS5uYW1lLCB0cnVlKTtcbiAgfVxuXG4gIGlmIChkYXRhLnN0b3JlKSB7XG4gICAgZW50cnkuc2V0TWV0aG9kKDApO1xuICB9XG5cbiAgaWYgKGRhdGEuY29tbWVudC5sZW5ndGggPiAwKSB7XG4gICAgZW50cnkuc2V0Q29tbWVudChkYXRhLmNvbW1lbnQpO1xuICB9XG5cbiAgaWYgKGRhdGEudHlwZSA9PT0gJ3N5bWxpbmsnICYmIHR5cGVvZiBkYXRhLm1vZGUgIT09ICdudW1iZXInKSB7XG4gICAgZGF0YS5tb2RlID0gNDA5NjA7IC8vIDAxMjAwMDBcbiAgfVxuXG4gIGlmICh0eXBlb2YgZGF0YS5tb2RlID09PSAnbnVtYmVyJykge1xuICAgIGlmIChkYXRhLnR5cGUgPT09ICdzeW1saW5rJykge1xuICAgICAgZGF0YS5tb2RlIHw9IDQwOTYwO1xuICAgIH1cblxuICAgIGVudHJ5LnNldFVuaXhNb2RlKGRhdGEubW9kZSk7XG4gIH1cblxuICBpZiAoZGF0YS50eXBlID09PSAnc3ltbGluaycgJiYgdHlwZW9mIGRhdGEubGlua25hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgc291cmNlID0gQnVmZmVyLmZyb20oZGF0YS5saW5rbmFtZSk7XG4gIH1cblxuICByZXR1cm4gWmlwQXJjaGl2ZU91dHB1dFN0cmVhbS5wcm90b3R5cGUuZW50cnkuY2FsbCh0aGlzLCBlbnRyeSwgc291cmNlLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIEZpbmFsaXplcyB0aGUgaW5zdGFuY2UgYW5kIHByZXZlbnRzIGZ1cnRoZXIgYXBwZW5kaW5nIHRvIHRoZSBhcmNoaXZlXG4gKiBzdHJ1Y3R1cmUgKHF1ZXVlIHdpbGwgY29udGludWUgdGlsIGRyYWluZWQpLlxuICpcbiAqIEByZXR1cm4gdm9pZFxuICovXG5aaXBTdHJlYW0ucHJvdG90eXBlLmZpbmFsaXplID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZmluaXNoKCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW4gdG8gdGhpcyBzdHJlYW0uXG4gKiBAZnVuY3Rpb24gWmlwU3RyZWFtI2dldEJ5dGVzV3JpdHRlblxuICogQHJldHVybnMge051bWJlcn1cbiAqL1xuXG4vKipcbiAqIENvbXByZXNzIENvbW1vbnMgWmlwQXJjaGl2ZU91dHB1dFN0cmVhbVxuICogQGV4dGVybmFsIFppcEFyY2hpdmVPdXRwdXRTdHJlYW1cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9hcmNoaXZlcmpzL25vZGUtY29tcHJlc3MtY29tbW9uc31cbiAqL1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/zip-stream/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/zip-stream/node_modules/archiver-utils/file.js":
/*!*********************************************************************!*\
  !*** ./node_modules/zip-stream/node_modules/archiver-utils/file.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * archiver-utils\n *\n * Copyright (c) 2012-2014 Chris Talkington, contributors.\n * Licensed under the MIT license.\n * https://github.com/archiverjs/node-archiver/blob/master/LICENSE-MIT\n */\nvar fs = __webpack_require__(/*! graceful-fs */ \"(rsc)/./node_modules/graceful-fs/graceful-fs.js\");\nvar path = __webpack_require__(/*! path */ \"path\");\n\nvar flatten = __webpack_require__(/*! lodash.flatten */ \"(rsc)/./node_modules/lodash.flatten/index.js\");\nvar difference = __webpack_require__(/*! lodash.difference */ \"(rsc)/./node_modules/lodash.difference/index.js\");\nvar union = __webpack_require__(/*! lodash.union */ \"(rsc)/./node_modules/lodash.union/index.js\");\nvar isPlainObject = __webpack_require__(/*! lodash.isplainobject */ \"(rsc)/./node_modules/lodash.isplainobject/index.js\");\n\nvar glob = __webpack_require__(/*! glob */ \"(rsc)/./node_modules/glob/glob.js\");\n\nvar file = module.exports = {};\n\nvar pathSeparatorRe = /[\\/\\\\]/g;\n\n// Process specified wildcard glob patterns or filenames against a\n// callback, excluding and uniquing files in the result set.\nvar processPatterns = function(patterns, fn) {\n  // Filepaths to return.\n  var result = [];\n  // Iterate over flattened patterns array.\n  flatten(patterns).forEach(function(pattern) {\n    // If the first character is ! it should be omitted\n    var exclusion = pattern.indexOf('!') === 0;\n    // If the pattern is an exclusion, remove the !\n    if (exclusion) { pattern = pattern.slice(1); }\n    // Find all matching files for this pattern.\n    var matches = fn(pattern);\n    if (exclusion) {\n      // If an exclusion, remove matching files.\n      result = difference(result, matches);\n    } else {\n      // Otherwise add matching files.\n      result = union(result, matches);\n    }\n  });\n  return result;\n};\n\n// True if the file path exists.\nfile.exists = function() {\n  var filepath = path.join.apply(path, arguments);\n  return fs.existsSync(filepath);\n};\n\n// Return an array of all file paths that match the given wildcard patterns.\nfile.expand = function(...args) {\n  // If the first argument is an options object, save those options to pass\n  // into the File.prototype.glob.sync method.\n  var options = isPlainObject(args[0]) ? args.shift() : {};\n  // Use the first argument if it's an Array, otherwise convert the arguments\n  // object to an array and use that.\n  var patterns = Array.isArray(args[0]) ? args[0] : args;\n  // Return empty set if there are no patterns or filepaths.\n  if (patterns.length === 0) { return []; }\n  // Return all matching filepaths.\n  var matches = processPatterns(patterns, function(pattern) {\n    // Find all matching files for this pattern.\n    return glob.sync(pattern, options);\n  });\n  // Filter result set?\n  if (options.filter) {\n    matches = matches.filter(function(filepath) {\n      filepath = path.join(options.cwd || '', filepath);\n      try {\n        if (typeof options.filter === 'function') {\n          return options.filter(filepath);\n        } else {\n          // If the file is of the right type and exists, this should work.\n          return fs.statSync(filepath)[options.filter]();\n        }\n      } catch(e) {\n        // Otherwise, it's probably not the right type.\n        return false;\n      }\n    });\n  }\n  return matches;\n};\n\n// Build a multi task \"files\" object dynamically.\nfile.expandMapping = function(patterns, destBase, options) {\n  options = Object.assign({\n    rename: function(destBase, destPath) {\n      return path.join(destBase || '', destPath);\n    }\n  }, options);\n  var files = [];\n  var fileByDest = {};\n  // Find all files matching pattern, using passed-in options.\n  file.expand(options, patterns).forEach(function(src) {\n    var destPath = src;\n    // Flatten?\n    if (options.flatten) {\n      destPath = path.basename(destPath);\n    }\n    // Change the extension?\n    if (options.ext) {\n      destPath = destPath.replace(/(\\.[^\\/]*)?$/, options.ext);\n    }\n    // Generate destination filename.\n    var dest = options.rename(destBase, destPath, options);\n    // Prepend cwd to src path if necessary.\n    if (options.cwd) { src = path.join(options.cwd, src); }\n    // Normalize filepaths to be unix-style.\n    dest = dest.replace(pathSeparatorRe, '/');\n    src = src.replace(pathSeparatorRe, '/');\n    // Map correct src path to dest path.\n    if (fileByDest[dest]) {\n      // If dest already exists, push this src onto that dest's src array.\n      fileByDest[dest].src.push(src);\n    } else {\n      // Otherwise create a new src-dest file mapping object.\n      files.push({\n        src: [src],\n        dest: dest,\n      });\n      // And store a reference for later use.\n      fileByDest[dest] = files[files.length - 1];\n    }\n  });\n  return files;\n};\n\n// reusing bits of grunt's multi-task source normalization\nfile.normalizeFilesArray = function(data) {\n  var files = [];\n\n  data.forEach(function(obj) {\n    var prop;\n    if ('src' in obj || 'dest' in obj) {\n      files.push(obj);\n    }\n  });\n\n  if (files.length === 0) {\n    return [];\n  }\n\n  files = _(files).chain().forEach(function(obj) {\n    if (!('src' in obj) || !obj.src) { return; }\n    // Normalize .src properties to flattened array.\n    if (Array.isArray(obj.src)) {\n      obj.src = flatten(obj.src);\n    } else {\n      obj.src = [obj.src];\n    }\n  }).map(function(obj) {\n    // Build options object, removing unwanted properties.\n    var expandOptions = Object.assign({}, obj);\n    delete expandOptions.src;\n    delete expandOptions.dest;\n\n    // Expand file mappings.\n    if (obj.expand) {\n      return file.expandMapping(obj.src, obj.dest, expandOptions).map(function(mapObj) {\n        // Copy obj properties to result.\n        var result = Object.assign({}, obj);\n        // Make a clone of the orig obj available.\n        result.orig = Object.assign({}, obj);\n        // Set .src and .dest, processing both as templates.\n        result.src = mapObj.src;\n        result.dest = mapObj.dest;\n        // Remove unwanted properties.\n        ['expand', 'cwd', 'flatten', 'rename', 'ext'].forEach(function(prop) {\n          delete result[prop];\n        });\n        return result;\n      });\n    }\n\n    // Copy obj properties to result, adding an .orig property.\n    var result = Object.assign({}, obj);\n    // Make a clone of the orig obj available.\n    result.orig = Object.assign({}, obj);\n\n    if ('src' in result) {\n      // Expose an expand-on-demand getter method as .src.\n      Object.defineProperty(result, 'src', {\n        enumerable: true,\n        get: function fn() {\n          var src;\n          if (!('result' in fn)) {\n            src = obj.src;\n            // If src is an array, flatten it. Otherwise, make it into an array.\n            src = Array.isArray(src) ? flatten(src) : [src];\n            // Expand src files, memoizing result.\n            fn.result = file.expand(expandOptions, src);\n          }\n          return fn.result;\n        }\n      });\n    }\n\n    if ('dest' in result) {\n      result.dest = obj.dest;\n    }\n\n    return result;\n  }).flatten().value();\n\n  return files;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvemlwLXN0cmVhbS9ub2RlX21vZHVsZXMvYXJjaGl2ZXItdXRpbHMvZmlsZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsbUJBQU8sQ0FBQyxvRUFBYTtBQUM5QixXQUFXLG1CQUFPLENBQUMsa0JBQU07O0FBRXpCLGNBQWMsbUJBQU8sQ0FBQyxvRUFBZ0I7QUFDdEMsaUJBQWlCLG1CQUFPLENBQUMsMEVBQW1CO0FBQzVDLFlBQVksbUJBQU8sQ0FBQyxnRUFBYztBQUNsQyxvQkFBb0IsbUJBQU8sQ0FBQyxnRkFBc0I7O0FBRWxELFdBQVcsbUJBQU8sQ0FBQywrQ0FBTTs7QUFFekI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHdDQUF3QztBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlcG9ydC1hc3Npc3RhbnQvLi9ub2RlX21vZHVsZXMvemlwLXN0cmVhbS9ub2RlX21vZHVsZXMvYXJjaGl2ZXItdXRpbHMvZmlsZS5qcz9mMjA5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogYXJjaGl2ZXItdXRpbHNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCBDaHJpcyBUYWxraW5ndG9uLCBjb250cmlidXRvcnMuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKiBodHRwczovL2dpdGh1Yi5jb20vYXJjaGl2ZXJqcy9ub2RlLWFyY2hpdmVyL2Jsb2IvbWFzdGVyL0xJQ0VOU0UtTUlUXG4gKi9cbnZhciBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJyk7XG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcblxudmFyIGZsYXR0ZW4gPSByZXF1aXJlKCdsb2Rhc2guZmxhdHRlbicpO1xudmFyIGRpZmZlcmVuY2UgPSByZXF1aXJlKCdsb2Rhc2guZGlmZmVyZW5jZScpO1xudmFyIHVuaW9uID0gcmVxdWlyZSgnbG9kYXNoLnVuaW9uJyk7XG52YXIgaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJ2xvZGFzaC5pc3BsYWlub2JqZWN0Jyk7XG5cbnZhciBnbG9iID0gcmVxdWlyZSgnZ2xvYicpO1xuXG52YXIgZmlsZSA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbnZhciBwYXRoU2VwYXJhdG9yUmUgPSAvW1xcL1xcXFxdL2c7XG5cbi8vIFByb2Nlc3Mgc3BlY2lmaWVkIHdpbGRjYXJkIGdsb2IgcGF0dGVybnMgb3IgZmlsZW5hbWVzIGFnYWluc3QgYVxuLy8gY2FsbGJhY2ssIGV4Y2x1ZGluZyBhbmQgdW5pcXVpbmcgZmlsZXMgaW4gdGhlIHJlc3VsdCBzZXQuXG52YXIgcHJvY2Vzc1BhdHRlcm5zID0gZnVuY3Rpb24ocGF0dGVybnMsIGZuKSB7XG4gIC8vIEZpbGVwYXRocyB0byByZXR1cm4uXG4gIHZhciByZXN1bHQgPSBbXTtcbiAgLy8gSXRlcmF0ZSBvdmVyIGZsYXR0ZW5lZCBwYXR0ZXJucyBhcnJheS5cbiAgZmxhdHRlbihwYXR0ZXJucykuZm9yRWFjaChmdW5jdGlvbihwYXR0ZXJuKSB7XG4gICAgLy8gSWYgdGhlIGZpcnN0IGNoYXJhY3RlciBpcyAhIGl0IHNob3VsZCBiZSBvbWl0dGVkXG4gICAgdmFyIGV4Y2x1c2lvbiA9IHBhdHRlcm4uaW5kZXhPZignIScpID09PSAwO1xuICAgIC8vIElmIHRoZSBwYXR0ZXJuIGlzIGFuIGV4Y2x1c2lvbiwgcmVtb3ZlIHRoZSAhXG4gICAgaWYgKGV4Y2x1c2lvbikgeyBwYXR0ZXJuID0gcGF0dGVybi5zbGljZSgxKTsgfVxuICAgIC8vIEZpbmQgYWxsIG1hdGNoaW5nIGZpbGVzIGZvciB0aGlzIHBhdHRlcm4uXG4gICAgdmFyIG1hdGNoZXMgPSBmbihwYXR0ZXJuKTtcbiAgICBpZiAoZXhjbHVzaW9uKSB7XG4gICAgICAvLyBJZiBhbiBleGNsdXNpb24sIHJlbW92ZSBtYXRjaGluZyBmaWxlcy5cbiAgICAgIHJlc3VsdCA9IGRpZmZlcmVuY2UocmVzdWx0LCBtYXRjaGVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3RoZXJ3aXNlIGFkZCBtYXRjaGluZyBmaWxlcy5cbiAgICAgIHJlc3VsdCA9IHVuaW9uKHJlc3VsdCwgbWF0Y2hlcyk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIFRydWUgaWYgdGhlIGZpbGUgcGF0aCBleGlzdHMuXG5maWxlLmV4aXN0cyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZmlsZXBhdGggPSBwYXRoLmpvaW4uYXBwbHkocGF0aCwgYXJndW1lbnRzKTtcbiAgcmV0dXJuIGZzLmV4aXN0c1N5bmMoZmlsZXBhdGgpO1xufTtcblxuLy8gUmV0dXJuIGFuIGFycmF5IG9mIGFsbCBmaWxlIHBhdGhzIHRoYXQgbWF0Y2ggdGhlIGdpdmVuIHdpbGRjYXJkIHBhdHRlcm5zLlxuZmlsZS5leHBhbmQgPSBmdW5jdGlvbiguLi5hcmdzKSB7XG4gIC8vIElmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhbiBvcHRpb25zIG9iamVjdCwgc2F2ZSB0aG9zZSBvcHRpb25zIHRvIHBhc3NcbiAgLy8gaW50byB0aGUgRmlsZS5wcm90b3R5cGUuZ2xvYi5zeW5jIG1ldGhvZC5cbiAgdmFyIG9wdGlvbnMgPSBpc1BsYWluT2JqZWN0KGFyZ3NbMF0pID8gYXJncy5zaGlmdCgpIDoge307XG4gIC8vIFVzZSB0aGUgZmlyc3QgYXJndW1lbnQgaWYgaXQncyBhbiBBcnJheSwgb3RoZXJ3aXNlIGNvbnZlcnQgdGhlIGFyZ3VtZW50c1xuICAvLyBvYmplY3QgdG8gYW4gYXJyYXkgYW5kIHVzZSB0aGF0LlxuICB2YXIgcGF0dGVybnMgPSBBcnJheS5pc0FycmF5KGFyZ3NbMF0pID8gYXJnc1swXSA6IGFyZ3M7XG4gIC8vIFJldHVybiBlbXB0eSBzZXQgaWYgdGhlcmUgYXJlIG5vIHBhdHRlcm5zIG9yIGZpbGVwYXRocy5cbiAgaWYgKHBhdHRlcm5zLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gW107IH1cbiAgLy8gUmV0dXJuIGFsbCBtYXRjaGluZyBmaWxlcGF0aHMuXG4gIHZhciBtYXRjaGVzID0gcHJvY2Vzc1BhdHRlcm5zKHBhdHRlcm5zLCBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gICAgLy8gRmluZCBhbGwgbWF0Y2hpbmcgZmlsZXMgZm9yIHRoaXMgcGF0dGVybi5cbiAgICByZXR1cm4gZ2xvYi5zeW5jKHBhdHRlcm4sIG9wdGlvbnMpO1xuICB9KTtcbiAgLy8gRmlsdGVyIHJlc3VsdCBzZXQ/XG4gIGlmIChvcHRpb25zLmZpbHRlcikge1xuICAgIG1hdGNoZXMgPSBtYXRjaGVzLmZpbHRlcihmdW5jdGlvbihmaWxlcGF0aCkge1xuICAgICAgZmlsZXBhdGggPSBwYXRoLmpvaW4ob3B0aW9ucy5jd2QgfHwgJycsIGZpbGVwYXRoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5maWx0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gb3B0aW9ucy5maWx0ZXIoZmlsZXBhdGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIElmIHRoZSBmaWxlIGlzIG9mIHRoZSByaWdodCB0eXBlIGFuZCBleGlzdHMsIHRoaXMgc2hvdWxkIHdvcmsuXG4gICAgICAgICAgcmV0dXJuIGZzLnN0YXRTeW5jKGZpbGVwYXRoKVtvcHRpb25zLmZpbHRlcl0oKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSwgaXQncyBwcm9iYWJseSBub3QgdGhlIHJpZ2h0IHR5cGUuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbWF0Y2hlcztcbn07XG5cbi8vIEJ1aWxkIGEgbXVsdGkgdGFzayBcImZpbGVzXCIgb2JqZWN0IGR5bmFtaWNhbGx5LlxuZmlsZS5leHBhbmRNYXBwaW5nID0gZnVuY3Rpb24ocGF0dGVybnMsIGRlc3RCYXNlLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICByZW5hbWU6IGZ1bmN0aW9uKGRlc3RCYXNlLCBkZXN0UGF0aCkge1xuICAgICAgcmV0dXJuIHBhdGguam9pbihkZXN0QmFzZSB8fCAnJywgZGVzdFBhdGgpO1xuICAgIH1cbiAgfSwgb3B0aW9ucyk7XG4gIHZhciBmaWxlcyA9IFtdO1xuICB2YXIgZmlsZUJ5RGVzdCA9IHt9O1xuICAvLyBGaW5kIGFsbCBmaWxlcyBtYXRjaGluZyBwYXR0ZXJuLCB1c2luZyBwYXNzZWQtaW4gb3B0aW9ucy5cbiAgZmlsZS5leHBhbmQob3B0aW9ucywgcGF0dGVybnMpLmZvckVhY2goZnVuY3Rpb24oc3JjKSB7XG4gICAgdmFyIGRlc3RQYXRoID0gc3JjO1xuICAgIC8vIEZsYXR0ZW4/XG4gICAgaWYgKG9wdGlvbnMuZmxhdHRlbikge1xuICAgICAgZGVzdFBhdGggPSBwYXRoLmJhc2VuYW1lKGRlc3RQYXRoKTtcbiAgICB9XG4gICAgLy8gQ2hhbmdlIHRoZSBleHRlbnNpb24/XG4gICAgaWYgKG9wdGlvbnMuZXh0KSB7XG4gICAgICBkZXN0UGF0aCA9IGRlc3RQYXRoLnJlcGxhY2UoLyhcXC5bXlxcL10qKT8kLywgb3B0aW9ucy5leHQpO1xuICAgIH1cbiAgICAvLyBHZW5lcmF0ZSBkZXN0aW5hdGlvbiBmaWxlbmFtZS5cbiAgICB2YXIgZGVzdCA9IG9wdGlvbnMucmVuYW1lKGRlc3RCYXNlLCBkZXN0UGF0aCwgb3B0aW9ucyk7XG4gICAgLy8gUHJlcGVuZCBjd2QgdG8gc3JjIHBhdGggaWYgbmVjZXNzYXJ5LlxuICAgIGlmIChvcHRpb25zLmN3ZCkgeyBzcmMgPSBwYXRoLmpvaW4ob3B0aW9ucy5jd2QsIHNyYyk7IH1cbiAgICAvLyBOb3JtYWxpemUgZmlsZXBhdGhzIHRvIGJlIHVuaXgtc3R5bGUuXG4gICAgZGVzdCA9IGRlc3QucmVwbGFjZShwYXRoU2VwYXJhdG9yUmUsICcvJyk7XG4gICAgc3JjID0gc3JjLnJlcGxhY2UocGF0aFNlcGFyYXRvclJlLCAnLycpO1xuICAgIC8vIE1hcCBjb3JyZWN0IHNyYyBwYXRoIHRvIGRlc3QgcGF0aC5cbiAgICBpZiAoZmlsZUJ5RGVzdFtkZXN0XSkge1xuICAgICAgLy8gSWYgZGVzdCBhbHJlYWR5IGV4aXN0cywgcHVzaCB0aGlzIHNyYyBvbnRvIHRoYXQgZGVzdCdzIHNyYyBhcnJheS5cbiAgICAgIGZpbGVCeURlc3RbZGVzdF0uc3JjLnB1c2goc3JjKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3RoZXJ3aXNlIGNyZWF0ZSBhIG5ldyBzcmMtZGVzdCBmaWxlIG1hcHBpbmcgb2JqZWN0LlxuICAgICAgZmlsZXMucHVzaCh7XG4gICAgICAgIHNyYzogW3NyY10sXG4gICAgICAgIGRlc3Q6IGRlc3QsXG4gICAgICB9KTtcbiAgICAgIC8vIEFuZCBzdG9yZSBhIHJlZmVyZW5jZSBmb3IgbGF0ZXIgdXNlLlxuICAgICAgZmlsZUJ5RGVzdFtkZXN0XSA9IGZpbGVzW2ZpbGVzLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBmaWxlcztcbn07XG5cbi8vIHJldXNpbmcgYml0cyBvZiBncnVudCdzIG11bHRpLXRhc2sgc291cmNlIG5vcm1hbGl6YXRpb25cbmZpbGUubm9ybWFsaXplRmlsZXNBcnJheSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgdmFyIGZpbGVzID0gW107XG5cbiAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBwcm9wO1xuICAgIGlmICgnc3JjJyBpbiBvYmogfHwgJ2Rlc3QnIGluIG9iaikge1xuICAgICAgZmlsZXMucHVzaChvYmopO1xuICAgIH1cbiAgfSk7XG5cbiAgaWYgKGZpbGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGZpbGVzID0gXyhmaWxlcykuY2hhaW4oKS5mb3JFYWNoKGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghKCdzcmMnIGluIG9iaikgfHwgIW9iai5zcmMpIHsgcmV0dXJuOyB9XG4gICAgLy8gTm9ybWFsaXplIC5zcmMgcHJvcGVydGllcyB0byBmbGF0dGVuZWQgYXJyYXkuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqLnNyYykpIHtcbiAgICAgIG9iai5zcmMgPSBmbGF0dGVuKG9iai5zcmMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmouc3JjID0gW29iai5zcmNdO1xuICAgIH1cbiAgfSkubWFwKGZ1bmN0aW9uKG9iaikge1xuICAgIC8vIEJ1aWxkIG9wdGlvbnMgb2JqZWN0LCByZW1vdmluZyB1bndhbnRlZCBwcm9wZXJ0aWVzLlxuICAgIHZhciBleHBhbmRPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb2JqKTtcbiAgICBkZWxldGUgZXhwYW5kT3B0aW9ucy5zcmM7XG4gICAgZGVsZXRlIGV4cGFuZE9wdGlvbnMuZGVzdDtcblxuICAgIC8vIEV4cGFuZCBmaWxlIG1hcHBpbmdzLlxuICAgIGlmIChvYmouZXhwYW5kKSB7XG4gICAgICByZXR1cm4gZmlsZS5leHBhbmRNYXBwaW5nKG9iai5zcmMsIG9iai5kZXN0LCBleHBhbmRPcHRpb25zKS5tYXAoZnVuY3Rpb24obWFwT2JqKSB7XG4gICAgICAgIC8vIENvcHkgb2JqIHByb3BlcnRpZXMgdG8gcmVzdWx0LlxuICAgICAgICB2YXIgcmVzdWx0ID0gT2JqZWN0LmFzc2lnbih7fSwgb2JqKTtcbiAgICAgICAgLy8gTWFrZSBhIGNsb25lIG9mIHRoZSBvcmlnIG9iaiBhdmFpbGFibGUuXG4gICAgICAgIHJlc3VsdC5vcmlnID0gT2JqZWN0LmFzc2lnbih7fSwgb2JqKTtcbiAgICAgICAgLy8gU2V0IC5zcmMgYW5kIC5kZXN0LCBwcm9jZXNzaW5nIGJvdGggYXMgdGVtcGxhdGVzLlxuICAgICAgICByZXN1bHQuc3JjID0gbWFwT2JqLnNyYztcbiAgICAgICAgcmVzdWx0LmRlc3QgPSBtYXBPYmouZGVzdDtcbiAgICAgICAgLy8gUmVtb3ZlIHVud2FudGVkIHByb3BlcnRpZXMuXG4gICAgICAgIFsnZXhwYW5kJywgJ2N3ZCcsICdmbGF0dGVuJywgJ3JlbmFtZScsICdleHQnXS5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgICAgICBkZWxldGUgcmVzdWx0W3Byb3BdO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIENvcHkgb2JqIHByb3BlcnRpZXMgdG8gcmVzdWx0LCBhZGRpbmcgYW4gLm9yaWcgcHJvcGVydHkuXG4gICAgdmFyIHJlc3VsdCA9IE9iamVjdC5hc3NpZ24oe30sIG9iaik7XG4gICAgLy8gTWFrZSBhIGNsb25lIG9mIHRoZSBvcmlnIG9iaiBhdmFpbGFibGUuXG4gICAgcmVzdWx0Lm9yaWcgPSBPYmplY3QuYXNzaWduKHt9LCBvYmopO1xuXG4gICAgaWYgKCdzcmMnIGluIHJlc3VsdCkge1xuICAgICAgLy8gRXhwb3NlIGFuIGV4cGFuZC1vbi1kZW1hbmQgZ2V0dGVyIG1ldGhvZCBhcyAuc3JjLlxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc3VsdCwgJ3NyYycsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBmbigpIHtcbiAgICAgICAgICB2YXIgc3JjO1xuICAgICAgICAgIGlmICghKCdyZXN1bHQnIGluIGZuKSkge1xuICAgICAgICAgICAgc3JjID0gb2JqLnNyYztcbiAgICAgICAgICAgIC8vIElmIHNyYyBpcyBhbiBhcnJheSwgZmxhdHRlbiBpdC4gT3RoZXJ3aXNlLCBtYWtlIGl0IGludG8gYW4gYXJyYXkuXG4gICAgICAgICAgICBzcmMgPSBBcnJheS5pc0FycmF5KHNyYykgPyBmbGF0dGVuKHNyYykgOiBbc3JjXTtcbiAgICAgICAgICAgIC8vIEV4cGFuZCBzcmMgZmlsZXMsIG1lbW9pemluZyByZXN1bHQuXG4gICAgICAgICAgICBmbi5yZXN1bHQgPSBmaWxlLmV4cGFuZChleHBhbmRPcHRpb25zLCBzcmMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZm4ucmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoJ2Rlc3QnIGluIHJlc3VsdCkge1xuICAgICAgcmVzdWx0LmRlc3QgPSBvYmouZGVzdDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9KS5mbGF0dGVuKCkudmFsdWUoKTtcblxuICByZXR1cm4gZmlsZXM7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/zip-stream/node_modules/archiver-utils/file.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/zip-stream/node_modules/archiver-utils/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/zip-stream/node_modules/archiver-utils/index.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * archiver-utils\n *\n * Copyright (c) 2015 Chris Talkington.\n * Licensed under the MIT license.\n * https://github.com/archiverjs/archiver-utils/blob/master/LICENSE\n */\nvar fs = __webpack_require__(/*! graceful-fs */ \"(rsc)/./node_modules/graceful-fs/graceful-fs.js\");\nvar path = __webpack_require__(/*! path */ \"path\");\nvar lazystream = __webpack_require__(/*! lazystream */ \"(rsc)/./node_modules/lazystream/lib/lazystream.js\");\nvar normalizePath = __webpack_require__(/*! normalize-path */ \"(rsc)/./node_modules/normalize-path/index.js\");\nvar defaults = __webpack_require__(/*! lodash.defaults */ \"(rsc)/./node_modules/lodash.defaults/index.js\");\n\nvar Stream = (__webpack_require__(/*! stream */ \"stream\").Stream);\nvar PassThrough = (__webpack_require__(/*! readable-stream */ \"(rsc)/./node_modules/readable-stream/readable.js\").PassThrough);\n\nvar utils = module.exports = {};\nutils.file = __webpack_require__(/*! ./file.js */ \"(rsc)/./node_modules/zip-stream/node_modules/archiver-utils/file.js\");\n\nutils.collectStream = function(source, callback) {\n  var collection = [];\n  var size = 0;\n\n  source.on('error', callback);\n\n  source.on('data', function(chunk) {\n    collection.push(chunk);\n    size += chunk.length;\n  });\n\n  source.on('end', function() {\n    var buf = Buffer.alloc(size);\n    var offset = 0;\n\n    collection.forEach(function(data) {\n      data.copy(buf, offset);\n      offset += data.length;\n    });\n\n    callback(null, buf);\n  });\n};\n\nutils.dateify = function(dateish) {\n  dateish = dateish || new Date();\n\n  if (dateish instanceof Date) {\n    dateish = dateish;\n  } else if (typeof dateish === 'string') {\n    dateish = new Date(dateish);\n  } else {\n    dateish = new Date();\n  }\n\n  return dateish;\n};\n\n// this is slightly different from lodash version\nutils.defaults = function(object, source, guard) {\n  var args = arguments;\n  args[0] = args[0] || {};\n\n  return defaults(...args);\n};\n\nutils.isStream = function(source) {\n  return source instanceof Stream;\n};\n\nutils.lazyReadStream = function(filepath) {\n  return new lazystream.Readable(function() {\n    return fs.createReadStream(filepath);\n  });\n};\n\nutils.normalizeInputSource = function(source) {\n  if (source === null) {\n    return Buffer.alloc(0);\n  } else if (typeof source === 'string') {\n    return Buffer.from(source);\n  } else if (utils.isStream(source)) {\n    // Always pipe through a PassThrough stream to guarantee pausing the stream if it's already flowing,\n    // since it will only be processed in a (distant) future iteration of the event loop, and will lose\n    // data if already flowing now.\n    return source.pipe(new PassThrough());\n  }\n\n  return source;\n};\n\nutils.sanitizePath = function(filepath) {\n  return normalizePath(filepath, false).replace(/^\\w+:/, '').replace(/^(\\.\\.\\/|\\/)+/, '');\n};\n\nutils.trailingSlashIt = function(str) {\n  return str.slice(-1) !== '/' ? str + '/' : str;\n};\n\nutils.unixifyPath = function(filepath) {\n  return normalizePath(filepath, false).replace(/^\\w+:/, '');\n};\n\nutils.walkdir = function(dirpath, base, callback) {\n  var results = [];\n\n  if (typeof base === 'function') {\n    callback = base;\n    base = dirpath;\n  }\n\n  fs.readdir(dirpath, function(err, list) {\n    var i = 0;\n    var file;\n    var filepath;\n\n    if (err) {\n      return callback(err);\n    }\n\n    (function next() {\n      file = list[i++];\n\n      if (!file) {\n        return callback(null, results);\n      }\n\n      filepath = path.join(dirpath, file);\n\n      fs.stat(filepath, function(err, stats) {\n        results.push({\n          path: filepath,\n          relative: path.relative(base, filepath).replace(/\\\\/g, '/'),\n          stats: stats\n        });\n\n        if (stats && stats.isDirectory()) {\n          utils.walkdir(filepath, base, function(err, res) {\n            res.forEach(function(dirEntry) {\n              results.push(dirEntry);\n            });\n            next();\n          });\n        } else {\n          next();\n        }\n      });\n    })();\n  });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvemlwLXN0cmVhbS9ub2RlX21vZHVsZXMvYXJjaGl2ZXItdXRpbHMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLG1CQUFPLENBQUMsb0VBQWE7QUFDOUIsV0FBVyxtQkFBTyxDQUFDLGtCQUFNO0FBQ3pCLGlCQUFpQixtQkFBTyxDQUFDLHFFQUFZO0FBQ3JDLG9CQUFvQixtQkFBTyxDQUFDLG9FQUFnQjtBQUM1QyxlQUFlLG1CQUFPLENBQUMsc0VBQWlCOztBQUV4QyxhQUFhLG9EQUF3QjtBQUNyQyxrQkFBa0IsNEdBQXNDOztBQUV4RDtBQUNBLGFBQWEsbUJBQU8sQ0FBQyxzRkFBVzs7QUFFaEM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVwb3J0LWFzc2lzdGFudC8uL25vZGVfbW9kdWxlcy96aXAtc3RyZWFtL25vZGVfbW9kdWxlcy9hcmNoaXZlci11dGlscy9pbmRleC5qcz84MDExIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogYXJjaGl2ZXItdXRpbHNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQ2hyaXMgVGFsa2luZ3Rvbi5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9hcmNoaXZlcmpzL2FyY2hpdmVyLXV0aWxzL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqL1xudmFyIGZzID0gcmVxdWlyZSgnZ3JhY2VmdWwtZnMnKTtcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xudmFyIGxhenlzdHJlYW0gPSByZXF1aXJlKCdsYXp5c3RyZWFtJyk7XG52YXIgbm9ybWFsaXplUGF0aCA9IHJlcXVpcmUoJ25vcm1hbGl6ZS1wYXRoJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCdsb2Rhc2guZGVmYXVsdHMnKTtcblxudmFyIFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpLlN0cmVhbTtcbnZhciBQYXNzVGhyb3VnaCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpLlBhc3NUaHJvdWdoO1xuXG52YXIgdXRpbHMgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xudXRpbHMuZmlsZSA9IHJlcXVpcmUoJy4vZmlsZS5qcycpO1xuXG51dGlscy5jb2xsZWN0U3RyZWFtID0gZnVuY3Rpb24oc291cmNlLCBjYWxsYmFjaykge1xuICB2YXIgY29sbGVjdGlvbiA9IFtdO1xuICB2YXIgc2l6ZSA9IDA7XG5cbiAgc291cmNlLm9uKCdlcnJvcicsIGNhbGxiYWNrKTtcblxuICBzb3VyY2Uub24oJ2RhdGEnLCBmdW5jdGlvbihjaHVuaykge1xuICAgIGNvbGxlY3Rpb24ucHVzaChjaHVuayk7XG4gICAgc2l6ZSArPSBjaHVuay5sZW5ndGg7XG4gIH0pO1xuXG4gIHNvdXJjZS5vbignZW5kJywgZnVuY3Rpb24oKSB7XG4gICAgdmFyIGJ1ZiA9IEJ1ZmZlci5hbGxvYyhzaXplKTtcbiAgICB2YXIgb2Zmc2V0ID0gMDtcblxuICAgIGNvbGxlY3Rpb24uZm9yRWFjaChmdW5jdGlvbihkYXRhKSB7XG4gICAgICBkYXRhLmNvcHkoYnVmLCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0ICs9IGRhdGEubGVuZ3RoO1xuICAgIH0pO1xuXG4gICAgY2FsbGJhY2sobnVsbCwgYnVmKTtcbiAgfSk7XG59O1xuXG51dGlscy5kYXRlaWZ5ID0gZnVuY3Rpb24oZGF0ZWlzaCkge1xuICBkYXRlaXNoID0gZGF0ZWlzaCB8fCBuZXcgRGF0ZSgpO1xuXG4gIGlmIChkYXRlaXNoIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIGRhdGVpc2ggPSBkYXRlaXNoO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRlaXNoID09PSAnc3RyaW5nJykge1xuICAgIGRhdGVpc2ggPSBuZXcgRGF0ZShkYXRlaXNoKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRlaXNoID0gbmV3IERhdGUoKTtcbiAgfVxuXG4gIHJldHVybiBkYXRlaXNoO1xufTtcblxuLy8gdGhpcyBpcyBzbGlnaHRseSBkaWZmZXJlbnQgZnJvbSBsb2Rhc2ggdmVyc2lvblxudXRpbHMuZGVmYXVsdHMgPSBmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgZ3VhcmQpIHtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIGFyZ3NbMF0gPSBhcmdzWzBdIHx8IHt9O1xuXG4gIHJldHVybiBkZWZhdWx0cyguLi5hcmdzKTtcbn07XG5cbnV0aWxzLmlzU3RyZWFtID0gZnVuY3Rpb24oc291cmNlKSB7XG4gIHJldHVybiBzb3VyY2UgaW5zdGFuY2VvZiBTdHJlYW07XG59O1xuXG51dGlscy5sYXp5UmVhZFN0cmVhbSA9IGZ1bmN0aW9uKGZpbGVwYXRoKSB7XG4gIHJldHVybiBuZXcgbGF6eXN0cmVhbS5SZWFkYWJsZShmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZnMuY3JlYXRlUmVhZFN0cmVhbShmaWxlcGF0aCk7XG4gIH0pO1xufTtcblxudXRpbHMubm9ybWFsaXplSW5wdXRTb3VyY2UgPSBmdW5jdGlvbihzb3VyY2UpIHtcbiAgaWYgKHNvdXJjZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oc291cmNlKTtcbiAgfSBlbHNlIGlmICh1dGlscy5pc1N0cmVhbShzb3VyY2UpKSB7XG4gICAgLy8gQWx3YXlzIHBpcGUgdGhyb3VnaCBhIFBhc3NUaHJvdWdoIHN0cmVhbSB0byBndWFyYW50ZWUgcGF1c2luZyB0aGUgc3RyZWFtIGlmIGl0J3MgYWxyZWFkeSBmbG93aW5nLFxuICAgIC8vIHNpbmNlIGl0IHdpbGwgb25seSBiZSBwcm9jZXNzZWQgaW4gYSAoZGlzdGFudCkgZnV0dXJlIGl0ZXJhdGlvbiBvZiB0aGUgZXZlbnQgbG9vcCwgYW5kIHdpbGwgbG9zZVxuICAgIC8vIGRhdGEgaWYgYWxyZWFkeSBmbG93aW5nIG5vdy5cbiAgICByZXR1cm4gc291cmNlLnBpcGUobmV3IFBhc3NUaHJvdWdoKCkpO1xuICB9XG5cbiAgcmV0dXJuIHNvdXJjZTtcbn07XG5cbnV0aWxzLnNhbml0aXplUGF0aCA9IGZ1bmN0aW9uKGZpbGVwYXRoKSB7XG4gIHJldHVybiBub3JtYWxpemVQYXRoKGZpbGVwYXRoLCBmYWxzZSkucmVwbGFjZSgvXlxcdys6LywgJycpLnJlcGxhY2UoL14oXFwuXFwuXFwvfFxcLykrLywgJycpO1xufTtcblxudXRpbHMudHJhaWxpbmdTbGFzaEl0ID0gZnVuY3Rpb24oc3RyKSB7XG4gIHJldHVybiBzdHIuc2xpY2UoLTEpICE9PSAnLycgPyBzdHIgKyAnLycgOiBzdHI7XG59O1xuXG51dGlscy51bml4aWZ5UGF0aCA9IGZ1bmN0aW9uKGZpbGVwYXRoKSB7XG4gIHJldHVybiBub3JtYWxpemVQYXRoKGZpbGVwYXRoLCBmYWxzZSkucmVwbGFjZSgvXlxcdys6LywgJycpO1xufTtcblxudXRpbHMud2Fsa2RpciA9IGZ1bmN0aW9uKGRpcnBhdGgsIGJhc2UsIGNhbGxiYWNrKSB7XG4gIHZhciByZXN1bHRzID0gW107XG5cbiAgaWYgKHR5cGVvZiBiYXNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBiYXNlO1xuICAgIGJhc2UgPSBkaXJwYXRoO1xuICB9XG5cbiAgZnMucmVhZGRpcihkaXJwYXRoLCBmdW5jdGlvbihlcnIsIGxpc3QpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGZpbGU7XG4gICAgdmFyIGZpbGVwYXRoO1xuXG4gICAgaWYgKGVycikge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgfVxuXG4gICAgKGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICBmaWxlID0gbGlzdFtpKytdO1xuXG4gICAgICBpZiAoIWZpbGUpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlc3VsdHMpO1xuICAgICAgfVxuXG4gICAgICBmaWxlcGF0aCA9IHBhdGguam9pbihkaXJwYXRoLCBmaWxlKTtcblxuICAgICAgZnMuc3RhdChmaWxlcGF0aCwgZnVuY3Rpb24oZXJyLCBzdGF0cykge1xuICAgICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICAgIHBhdGg6IGZpbGVwYXRoLFxuICAgICAgICAgIHJlbGF0aXZlOiBwYXRoLnJlbGF0aXZlKGJhc2UsIGZpbGVwYXRoKS5yZXBsYWNlKC9cXFxcL2csICcvJyksXG4gICAgICAgICAgc3RhdHM6IHN0YXRzXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChzdGF0cyAmJiBzdGF0cy5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgICAgdXRpbHMud2Fsa2RpcihmaWxlcGF0aCwgYmFzZSwgZnVuY3Rpb24oZXJyLCByZXMpIHtcbiAgICAgICAgICAgIHJlcy5mb3JFYWNoKGZ1bmN0aW9uKGRpckVudHJ5KSB7XG4gICAgICAgICAgICAgIHJlc3VsdHMucHVzaChkaXJFbnRyeSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pKCk7XG4gIH0pO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/zip-stream/node_modules/archiver-utils/index.js\n");

/***/ })

};
;